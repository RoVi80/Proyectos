#!/usr/bin/env python3

from unittest import TestCase

# catch potential exception from import
try:
    from public.onsite_restaurant import OnsiteRestaurant
except Exception:
    # Just make sure that all tests are still executed to have a stable number
    # of exercise points. An appropriate warning is generated by the smoke tests.
    pass


class OnsiteRestaurantTest(TestCase):

    def test00_occupy_table(self):
        try:
            sut = OnsiteRestaurant("r", "a", 20)
            sut.occupy_table()
        except:
            m = "@@Unexpected error when occupying a table.@@"
            self.fail(m)
        m = "@@occupying a table should decrement the number of available tables.@@"
        self.assertEqual(19, sut.get_available_tables(), m)

    def test01_occupy_table_fail(self):
        try:
            sut = OnsiteRestaurant("r", "a", 0)
            sut.occupy_table()
        except Exception as actual_exception:
            actual_exception_type = type(actual_exception)

            if Warning != actual_exception_type:
                m = "@@Trying to occupy a table for 0 available tables should trigger a Warning (expected: {}, was: {})@@".format(
                    Warning.__name__, actual_exception_type.__name__)
                self.fail(m)
        else:
            m = "@@Trying to occupy a table for 0 available tables should trigger a Warning@@"
            self.fail(m)

    def test02_free_table(self):
        try:
            sut = OnsiteRestaurant("r", "a", 20)
            sut.open_restaurant()
            sut.occupy_table()
            sut.occupy_table()
            sut.free_table()
        except:
            m = "@@Unexpected error when occupying/freeing a table.@@"
            self.fail(m)
        m = "@@Occupying a table should decrement the number of available tables.@@"
        self.assertEqual(19, sut.get_available_tables(), m)

    def test03_free_table_fail(self):

        try:
            sut = OnsiteRestaurant("r", "a", 1)
            sut.free_table()
        except Exception as actual_exception:
            actual_exception_type = type(actual_exception)

            if Warning != actual_exception_type:
                m = "@@Trying to free a table if max number of tables are free should trigger a Warning@@ (expected: {}, was: {})@@".format(
                    Warning.__name__, actual_exception_type.__name__)
                self.fail(m)
        else:
            m = "@@Trying to free a table if max number of tables are free should trigger a Warning@@"
            self.fail(m)


    def test04_descr_restaurant_parent(self):
        try:
            name = "rest1"
            cuisine = "allcuisine"
            sut = OnsiteRestaurant(name, cuisine, 10)
            actual = sut.describe_restaurant()
        except:
            m = "@@Unexpected error when describing onsite restaurant.@@"
            self.fail(m)
        m = "@@describe_restaurant() should return a string with both the name and the cuisine_type of the restaurant.@@"
        contains_name = actual.find(name)
        contains_cuisine = actual.find(cuisine)
        self.assertTrue(contains_name != -1, m)
        self.assertTrue(contains_cuisine != -1, m)

    def test05_is_open(self):
        s = 3
        try:
            name = "rest1"
            cuisine = "allcuisine"
            sut = OnsiteRestaurant(name, cuisine, 10, True)

            sut.add_consumption_unit("ice tea", s)
            sut.sell_unit("ice tea")
            actual = sut.get_sales()
        except:
            m = "@@The is_open param needs to be passed to the parent in the constructor.@@"
            self.fail(m)
        m = f"@@sales should be {s} but was {actual}.@@"
        self.assertEqual(s, actual, m)
